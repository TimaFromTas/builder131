<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Builder — Version 1.4.3</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --primary-color: #f0c200;
      --bg-dark: #121212;
      --panel-bg: #222;
    }
    body {
      margin: 0;
      background: var(--bg-dark);
      color: #eaeaea;
      font-family: 'Segoe UI', system-ui, sans-serif;
      touch-action: manipulation;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }
    #game-container {
      position: relative;
      width: 100%;
      max-width: 448px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      aspect-ratio: 14 / 20;
      background: #0a0a0a;
      border: 4px solid #333;
      border-radius: 12px;
      box-shadow: inset 0 0 30px #000, 0 10px 25px rgba(0,0,0,0.5);
    }
    .ctrl-btn {
      background: #333;
      border-radius: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      color: white;
      user-select: none;
      border: 1px solid #444;
      box-shadow: 0 5px 0 #1a1a1a;
      height: 64px;
      transition: all 0.1s;
      cursor: pointer;
    }
    .ctrl-btn:active {
      background: #444;
      transform: translateY(3px);
      box-shadow: 0 2px 0 #1a1a1a;
    }
    .modal-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(6px);
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      border-radius: 12px;
    }
    .menu-card {
      background: var(--panel-bg);
      padding: 30px;
      border-radius: 24px;
      border: 2px solid var(--primary-color);
      width: 100%;
      max-width: 320px;
      text-align: center;
      box-shadow: 0 0 50px rgba(240, 194, 0, 0.2);
    }
    select {
      appearance: none;
      background: #111;
      border: 1px solid #444;
      color: white;
      padding: 10px;
      border-radius: 8px;
      width: 100%;
      margin-top: 4px;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <div id="game-container">
    <h1 class="text-center text-yellow-500 font-black text-2xl tracking-tighter uppercase italic">Builder 1.4.3</h1>
    
    <div class="flex justify-between items-center bg-[#222] p-3 rounded-xl border border-gray-700 shadow-xl">
      <div class="flex flex-col">
        <span class="text-[10px] text-gray-500 font-bold uppercase leading-none">Status</span>
        <span id="status-label" class="text-sm font-bold text-yellow-500 uppercase">Ready</span>
      </div>
      <div id="timer-display" class="text-2xl font-mono text-yellow-500 font-bold tracking-widest">00:00</div>
    </div>

    <canvas id="game-canvas" width="448" height="640"></canvas>

    <div class="grid grid-cols-3 gap-3 w-full max-w-[340px] mx-auto mt-2">
      <div class="ctrl-btn" id="btn-left">←</div>
      <div class="ctrl-btn" id="btn-rotate">↻</div>
      <div class="ctrl-btn" id="btn-right">→</div>
      <div class="ctrl-btn" id="btn-pause">⏸</div>
      <div class="ctrl-btn" id="btn-down">↓</div>
    </div>

    <div id="menu-modal" class="modal-overlay">
      <div class="menu-card">
        <h2 id="menu-title" class="text-3xl font-black text-yellow-500 mb-6 italic">BUILDER</h2>
        
        <div class="text-left mb-4">
          <label class="text-[11px] text-gray-500 font-bold uppercase ml-1">Скорость (Speed)</label>
          <select id="speed-select">
            <option value="1">Easy</option>
            <option value="3" selected>Medium</option>
            <option value="5">Hard</option>
          </select>
        </div>

        <div class="text-left mb-8">
          <label class="text-[11px] text-gray-500 font-bold uppercase ml-1">Сложность (Difficulty)</label>
          <select id="diff-select">
            <option value="0">1 (Пусто)</option>
            <option value="10">2 (Средне)</option>
            <option value="20" selected>3 (Сложно)</option>
          </select>
        </div>

        <button id="start-btn" class="w-full bg-yellow-500 text-black font-black py-4 rounded-xl hover:bg-yellow-400 active:scale-95 transition-all shadow-lg">
          START GAME
        </button>
      </div>
    </div>

    <div id="victory-modal" class="modal-overlay hidden">
      <div class="menu-card border-green-500 shadow-[0_0_50px_rgba(34,197,94,0.2)]">
        <h2 class="text-3xl font-black text-green-500 mb-2 italic">VICTORY!</h2>
        <p id="final-time" class="text-white mb-6 font-mono text-2xl bg-black py-2 rounded-lg">Время: 00:00</p>
        <input id="player-name" type="text" placeholder="Ваше имя" class="w-full bg-black border border-gray-700 p-4 rounded-xl mb-4 text-center text-white focus:border-green-500 outline-none">
        <button id="submit-score-btn" class="w-full bg-green-500 text-black font-black py-4 rounded-xl hover:bg-green-400 active:scale-95 transition-all shadow-lg">
          СОХРАНИТЬ
        </button>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js";
    import { getFirestore, collection, addDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.1.0/firebase-auth.js";

    const firebaseConfig = JSON.parse(__firebase_config);
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'builder-v1-4';

    let currentUser = null;
    signInAnonymously(auth).catch(console.error);
    onAuthStateChanged(auth, (user) => { currentUser = user; });

    const COLS = 14, ROWS = 20, CELL = 32;
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");

    const SHAPES = [
      { name:"I", matrix:[[1,1,1,1]] },
      { name:"J", matrix:[[1,0,0],[1,1,1]] },
      { name:"L", matrix:[[0,0,1],[1,1,1]] },
      { name:"O", matrix:[[1,1],[1,1]] },
      { name:"S", matrix:[[0,1,1],[1,1,0]] },
      { name:"T", matrix:[[0,1,0],[1,1,1]] },
      { name:"Z", matrix:[[1,1,0],[0,1,1]] }
    ];

    let board = [];
    let worker = { row: 18, col: 7, visualX: 7*CELL, visualY: 17*CELL, dir: 1, alive: true, animFrame: 0 };
    let currentShape = null;
    let shapePos = { r: 0, c: 0 };
    let timerMs = 0, lastTs = 0;
    let running = false;
    let dropCounter = 0, workerCounter = 0;
    let speedSetting = 3;

    const menuModal = document.getElementById("menu-modal");
    const victoryModal = document.getElementById("victory-modal");
    const startBtn = document.getElementById("start-btn");
    const timerDisplay = document.getElementById("timer-display");
    const playerNameInput = document.getElementById("player-name");
    const submitScoreBtn = document.getElementById("submit-score-btn");
    const statusLabel = document.getElementById("status-label");

    function initGame() {
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      const diffCount = parseInt(document.getElementById("diff-select").value);
      speedSetting = parseInt(document.getElementById("speed-select").value);
      
      let placed = 0;
      while (placed < diffCount) {
        let r = ROWS - 1 - Math.floor(Math.random() * 8); 
        let c = Math.floor(Math.random() * COLS);
        if (board[r][c] === 0 && !(c === 7 && r >= 17)) {
          board[r][c] = 1;
          placed++;
        }
      }

      worker = { row: 18, col: 7, visualX: 7*CELL, visualY: 18*CELL, dir: 1, alive: true, reached: false, animFrame: 0 };
      timerMs = 0;
      dropCounter = 0;
      workerCounter = 0;
      currentShape = null;
      running = true;
      
      menuModal.classList.add("hidden");
      victoryModal.classList.add("hidden");
      statusLabel.textContent = "Строим";
      lastTs = performance.now();
      requestAnimationFrame(gameLoop);
    }

    function spawnShape() {
      const s = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      currentShape = s.matrix;
      shapePos = { r: 0, c: Math.floor((COLS - currentShape[0].length) / 2) };
      
      if (checkCollision(shapePos.r, shapePos.c, currentShape)) {
        endGame("CAVE-IN");
      }
    }

    function checkCollision(r, c, shape) {
      for (let row = 0; row < shape.length; row++) {
        for (let col = 0; col < shape[row].length; col++) {
          if (shape[row][col]) {
            let nr = r + row;
            let nc = c + col;
            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS || board[nr][nc]) return true;
            if (worker.alive && nc === worker.col && (nr === worker.row || nr === worker.row + 1)) return true;
          }
        }
      }
      return false;
    }

    function lockShape() {
      currentShape.forEach((row, r) => {
        row.forEach((v, c) => {
          if (v) board[shapePos.r + r][shapePos.c + c] = 1;
        });
      });
      
      if (worker.col === shapePos.c && (worker.row >= shapePos.r && worker.row < shapePos.r + currentShape.length)) {
          worker.alive = false;
          endGame("CRUSHED");
          return;
      }

      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== 0)) {
          board.splice(r, 1);
          board.unshift(Array(COLS).fill(0));
          r++;
        }
      }
      currentShape = null;
    }

    function updateWorker() {
      if (!worker.alive || worker.reached || !running) return;

      if (worker.row <= 3 && (worker.col === 0 || worker.col === COLS - 1)) {
        worker.reached = true;
        endGame("VICTORY");
        return;
      }

      if (worker.row < ROWS - 2 && !board[worker.row + 2][worker.col]) {
        let blockAbove = false;
        if (currentShape) {
            currentShape.forEach((row, r) => row.forEach((v, c) => {
                if (v && (shapePos.c + c === worker.col) && (shapePos.r + r === worker.row + 2)) blockAbove = true;
            }));
        }
        if (!blockAbove) {
            worker.row++;
            return;
        }
      }

      let nextCol = worker.col + worker.dir;
      if (nextCol < 0 || nextCol >= COLS) {
        worker.dir *= -1;
        return;
      }

      const isPathClear = (r, c) => {
        if (c < 0 || c >= COLS || r < 0 || r >= ROWS - 1) return false;
        let blockedByStatic = board[r][c] || board[r+1][c];
        let blockedByFalling = false;
        if (currentShape) {
            currentShape.forEach((row, sr) => row.forEach((v, sc) => {
                if (v && (shapePos.c + sc === c) && (shapePos.r + sr === r || shapePos.r + sr === r + 1)) blockedByFalling = true;
            }));
        }
        return !blockedByStatic && !blockedByFalling;
      };

      if (isPathClear(worker.row, nextCol)) {
        worker.col = nextCol;
        worker.animFrame++; // Двигаем ноги
      } else if (isPathClear(worker.row - 1, nextCol) && (board[worker.row + 1][nextCol])) {
        worker.row--;
        worker.col = nextCol;
        worker.animFrame++;
      } else {
        worker.dir *= -1;
      }
    }

    function endGame(type) {
      running = false;
      if (type === "VICTORY") {
        const sec = Math.floor(timerMs / 1000);
        const mm = String(Math.floor(sec / 60)).padStart(2, '0');
        const ss = String(sec % 60).padStart(2, '0');
        document.getElementById("final-time").textContent = `Время: ${mm}:${ss}`;
        victoryModal.classList.remove("hidden");
      } else {
        document.getElementById("menu-title").textContent = type === "CAVE-IN" ? "ОБВАЛ" : "РАЗДАВЛЕН";
        document.getElementById("menu-title").style.color = "#ff5252";
        document.getElementById("start-btn").textContent = "ПОВТОРИТЬ";
        menuModal.classList.remove("hidden");
      }
    }

    async function saveScore() {
      if (!currentUser) return;
      const name = playerNameInput.value || "Строитель";
      const sec = Math.floor(timerMs / 1000);
      const mm = String(Math.floor(sec / 60)).padStart(2, '0');
      const ss = String(sec % 60).padStart(2, '0');

      try {
        await addDoc(collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard'), {
          playerName: name,
          timeFormatted: `${mm}:${ss}`,
          seconds: sec,
          speed: document.getElementById("speed-select").value,
          difficulty: document.getElementById("diff-select").value,
          createdAt: serverTimestamp()
        });
        location.reload();
      } catch (e) { console.error(e); }
    }

    function gameLoop(ts) {
      if (!running) return;
      const dt = ts - lastTs;
      lastTs = ts;
      timerMs += dt;

      const totalSec = Math.floor(timerMs/1000);
      timerDisplay.textContent = `${String(Math.floor(totalSec/60)).padStart(2,'0')}:${String(totalSec%60).padStart(2,'0')}`;

      if (!currentShape) spawnShape();

      dropCounter += dt;
      const dropInterval = (1100 - speedSetting * 180);
      if (dropCounter > dropInterval) {
        dropCounter = 0;
        if (!checkCollision(shapePos.r + 1, shapePos.c, currentShape)) {
          shapePos.r++;
        } else {
          lockShape();
        }
      }

      workerCounter += dt;
      if (workerCounter > 150) {
        workerCounter = 0;
        updateWorker();
      }

      draw();
      requestAnimationFrame(gameLoop);
    }

    function drawBrick(x, y, color1, color2) {
      const grad = ctx.createLinearGradient(x, y, x + CELL, y + CELL);
      grad.addColorStop(0, color1);
      grad.addColorStop(1, color2);
      ctx.fillStyle = grad;
      ctx.fillRect(x + 1, y + 1, CELL - 2, CELL - 2);
      
      // Текстура кирпича
      ctx.strokeStyle = "rgba(0,0,0,0.2)";
      ctx.lineWidth = 1;
      // Горизонтальная линия посередине (имитация кладки)
      ctx.beginPath();
      ctx.moveTo(x + 1, y + CELL/2);
      ctx.lineTo(x + CELL - 1, y + CELL/2);
      ctx.stroke();
      // Вертикальные швы
      ctx.beginPath();
      ctx.moveTo(x + CELL/2, y + 1);
      ctx.lineTo(x + CELL/2, y + CELL/2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + CELL/4, y + CELL/2);
      ctx.lineTo(x + CELL/4, y + CELL - 1);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x + (3*CELL)/4, y + CELL/2);
      ctx.lineTo(x + (3*CELL)/4, y + CELL - 1);
      ctx.stroke();

      // Светлый блик
      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.strokeRect(x + 2, y + 2, CELL - 4, CELL - 4);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = "#121212";
      ctx.lineWidth = 1;
      for(let i=0; i<=COLS; i++) {
          ctx.beginPath(); ctx.moveTo(i*CELL, 0); ctx.lineTo(i*CELL, ROWS*CELL); ctx.stroke();
      }
      for(let i=0; i<=ROWS; i++) {
          ctx.beginPath(); ctx.moveTo(0, i*CELL); ctx.lineTo(COLS*CELL, i*CELL); ctx.stroke();
      }

      // Выходы
      ctx.fillStyle = "#22c55e";
      ctx.fillRect(0, 2 * CELL, 8, 2 * CELL);
      ctx.fillRect(canvas.width - 8, 2 * CELL, 8, 2 * CELL);

      // Отрисовка заблокированных блоков (коричневые)
      board.forEach((row, r) => {
        row.forEach((v, c) => {
          if (v) {
            drawBrick(c * CELL, r * CELL, "#8b4513", "#5d2e0d");
          }
        });
      });

      // Отрисовка падающей фигуры (желтые кирпичи)
      if (currentShape) {
        currentShape.forEach((row, r) => {
          row.forEach((v, c) => {
            if (v) {
              drawBrick((shapePos.c + c) * CELL, (shapePos.r + r) * CELL, "#f0c200", "#b8860b");
            }
          });
        });
      }

      if (worker.alive && !worker.reached) {
        worker.visualX += (worker.col * CELL - worker.visualX) * 0.3;
        worker.visualY += (worker.row * CELL - worker.visualY) * 0.3;
        
        const x = worker.visualX;
        const y = worker.visualY;

        // Ноги
        ctx.fillStyle = "#333";
        const legOffset = Math.sin(worker.animFrame * 0.8) * 4;
        ctx.fillRect(x + 8, y + CELL * 1.6, 6, 12 + (worker.dir === 1 ? legOffset : -legOffset));
        ctx.fillRect(x + 18, y + CELL * 1.6, 6, 12 + (worker.dir === 1 ? -legOffset : legOffset));

        // Туловище
        ctx.fillStyle = "#2563eb";
        ctx.fillRect(x + 6, y + CELL * 0.6, 20, CELL);
        
        // Руки
        ctx.fillStyle = "#fecaca";
        ctx.fillRect(x + 2, y + CELL * 0.7, 5, 15);
        ctx.fillRect(x + 25, y + CELL * 0.7, 5, 15);

        // Голова
        ctx.fillStyle = "#fecaca";
        ctx.fillRect(x + 8, y + CELL * 0.1, 16, 16);

        // Каска
        ctx.fillStyle = "#f0c200";
        ctx.beginPath();
        ctx.arc(x + 16, y + CELL * 0.2, 10, Math.PI, 0);
        ctx.fill();
        ctx.fillRect(x + 4, y + CELL * 0.15, 24, 4);
        
        // Лицо
        ctx.fillStyle = "black";
        let eyeX = worker.dir === 1 ? x + 20 : x + 8;
        ctx.fillRect(eyeX, y + CELL * 0.3, 3, 3);
      }
    }

    function move(dir) {
      if (!running || !currentShape) return;
      if (!checkCollision(shapePos.r, shapePos.c + dir, currentShape)) {
        shapePos.c += dir;
      }
    }

    function rotate() {
      if (!running || !currentShape) return;
      const matrix = currentShape;
      const rotated = matrix[0].map((_, i) => matrix.map(row => row[i]).reverse());
      if (!checkCollision(shapePos.r, shapePos.c, rotated)) {
        currentShape = rotated;
      }
    }

    function hardDrop() {
      if (!running || !currentShape) return;
      while (!checkCollision(shapePos.r + 1, shapePos.c, currentShape)) {
        shapePos.r++;
      }
      lockShape();
    }

    startBtn.onclick = initGame;
    submitScoreBtn.onclick = saveScore;
    
    document.getElementById("btn-left").onclick = () => move(-1);
    document.getElementById("btn-right").onclick = () => move(1);
    document.getElementById("btn-rotate").onclick = rotate;
    document.getElementById("btn-down").onclick = hardDrop;
    document.getElementById("btn-pause").onclick = () => {
      running = !running;
      if(!running) {
          statusLabel.textContent = "Пауза";
          document.getElementById("menu-title").textContent = "ПАУЗА";
          document.getElementById("start-btn").textContent = "ПРОДОЛЖИТЬ";
          menuModal.classList.remove("hidden");
      } else {
          statusLabel.textContent = "Строим";
          menuModal.classList.add("hidden");
          lastTs = performance.now();
          requestAnimationFrame(gameLoop);
      }
    };

    window.addEventListener("keydown", e => {
      if (e.key === "ArrowLeft") move(-1);
      if (e.key === "ArrowRight") move(1);
      if (e.key === "ArrowUp") rotate();
      if (e.key === "ArrowDown") hardDrop();
      if (e.key === "Escape") document.getElementById("btn-pause").click();
    });

  </script>
</body>
</html>
